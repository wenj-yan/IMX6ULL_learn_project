### 一、c语言运行环境配置

- 设置处理器模式
  - 设置6ull处于SVC模式下。（超级管理员模式）——设置CPSR寄存器的bit4-0为10011=0x13
  - 读写状态寄存器需要用到MRS和MSR指令（见汇编基础），MRS将特殊寄存器的值读出到通用寄存器，相反MSR是写入。
- 设置SP指针（堆栈指针）
  - C语言需要入栈出栈
  - SP可以指向内部RAM，也可以指向DDR，我们将其指向DDR。
  - SP设置到哪里？512MB的话范围是0x80000000-0x9FFFFFFF。
  - 我们栈大小设置为0x200000=2MB
  - 对于A7而言，处理器栈的增长方式是向下增长的。（指针向低地址移动）
  - 所以设置为0x80200000
- 跳转到C语言
  - 使用B指令跳转到C语言的函数，比如main函数。

### 二、软件编写

这里只讲解一下makefile文件内容：

```makefile
objs = start.o main.o 

ledc.bin : $(objs)
	arm-linux-gnueabihf-ld -Timx6u.lds  $^ -o ledc.elf
	arm-linux-gnueabihf-objcopy -O binary -S ledc.elf $@
	arm-linux-gnueabihf-objdump -D -m arm ledc.elf > ledc.dis

%.o : %.c
	arm-linux-gnueabihf-gcc -Wall -nostdlib -c  -o $@ $<


%.o : %.s
	arm-linux-gnueabihf-gcc -Wall -nostdlib -c      -o $@ $<


clean:
	rm -rf *.o ledc.bin ledc.elf ledc.dis
```

需要将对应的.c 源文件编译为.o 文件，每一个 C 文件都要写一个对应的规则，如果工程中 C 文件很多的话显然不能这么做。为此，我们可以使用 Makefile 中的模式规则，通过模式规则我们就可以使用一条规则来将所有的.c 文件编译为对应的.o 文件。

模式规则中，至少在**规则的目标定定义中要包涵“%”，否则就是一般规则**，目标中的“%” 表示对文件名的匹配，“%”表示长度任意的非空字符串，比如“%.c”就是所有的以.c 结尾的文件，类似与通配符，a.%.c 就表示以 a.开头，以.c 结束的所有文件。  当“%”出现在目标中的时候，目标中“%”所代表的值决定了依赖中的“%”值。

上面讲的模式规则中，目标和依赖都是一系列的文件，每一次对模式规则进行解析的时候都会是不同的目标和依赖文件，而命令只有一行，**如何通过一行命令来从不同的依赖文件中生成对应的目标？自动化变量**就是完成这个功能的！**所谓自动化变量就是这种变量会把模式中所定义的一系列的文件自动的挨个取出，直至所有的符合模式的文件都取完，自动化变量只应该出现在规则的命令中**，常用的自动化变量如表：

![image-20241103000602898](./C:/Users/wenjie/Documents/我的笔记/linux/assets/image-20241103000602898.png)

7 个自动化变量中，常用的三种：$@、$<和$^。

    $@ —— 目标集，首先必须是“目标”，其次这是个集，可以是1个，也可以是多个。
    
    $^—— 所有的依赖对象集，如果觉得拗口，可以理解为，所有的组成元素，这是个集，可以是1个，也可以是多个。
    
    $< —— 依赖对象集中的第一个，这里要说明一下，gcc只能编译*.c和.S文件，不能编译*.h头文件的，所以上面的

### 三、链接脚本

描述了链接得文件以及链接得顺序，以及链接的首地址

```
SECTIONS{
    . = 0x87800000;
    .text :
    {
        start.o
        *(.text)
    }
    .rodata ALIGN(4) : {*(.rodata*)}
    .data ALIGN(4) : {*(.data)}
    __bss_start=.;
    .bss ALIGN(4) : {*(.bss) *(COMMON)}
    __bss_end=.;
}
```

上面语句中我们是通过“-Ttext”来指定链接地址是 0X87800000 的，这样的话所有的文件 都会链接到以 0X87800000 为起始地址的区域。但是有时候我们很多文件需要链接到指定的区 域，或者叫做段里面，比如在 Linux 里面初始化函数就会放到 init 段里面。因此我们需要能够 自定义一些段，这些段的起始地址我们可以自由指定，同样的我们也可以指定一个文件或者函 数应该存放到哪个段里面去。要完成这个功能我们就需要使用到链接脚本，看名字就知道链接 脚本主要用于链接的，用于描述文件应该如何被链接在一起形成最终的可执行文件。其主要目 的是描述输入文件中的段如何被映射到输出文件中，并且控制输出文件中的内存排布。比如我 们编译生成的文件一般都包含 text 段、data 段等等。 